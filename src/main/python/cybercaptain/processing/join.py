"""
This module contains the processing join class.
"""
from cybercaptain.utils.exceptions import ValidationError
from cybercaptain.processing.base import processing_base
from cybercaptain.utils.jsonFileHandler import json_file_reader, json_file_writer
from cybercaptain.utils.helpers import keyGen, genBTree

class processing_join(processing_base):
    """
    The Join allows to join two different files into one based on the given attributes. (NOTE: the two attribute list must produce the same
     key!)
    The Join will be implemented as a left join, using the ``src`` as the left table and the ``joinwith`` as the right table.

    **Parameters**:
        kwargs:
            contains a dictionary of all attributes.

    **Script Attributes**:
        left-joinon:
            a list of attributes for the left side to join on.
        right-joinon:
            a list of attributes for the right side to join on.
        joinwith:
            the second file with which the join has to be done (rootPath auto appended to the given absolute src).
    """
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.validate(kwargs)

        # If subclass needs special variables define here
        self.left_joinon = kwargs.get("left-joinon")
        self.right_joinon = kwargs.get("right-joinon")
        self.joinwith = kwargs.get("joinwith")

    def run(self):
        """
        Runs the join algorythm.
        """
        self.cc_log("INFO", "Data Processing Join: Started")
        if self.left_joinon and isinstance(self.left_joinon, str): self.left_joinon = [self.left_joinon]
        if self.right_joinon and isinstance(self.right_joinon, str): self.right_joinon = [self.right_joinon]

        # Create the B-Tree for quick and easy search
        b_tree = genBTree(self.joinwith, self.left_joinon)

        json_fr = json_file_reader(self.src)
        json_fw = json_file_writer(self.target)

        # Loop through all the left table
        failed_counter = 0
        while not json_fr.isEOF():
            data = json_fr.readRecord()
            key = keyGen(self.right_joinon, data)
            (data, b_tree, failed_counter) = self.join(b_tree, key, data, failed_counter)
            json_fw.writeRecord(data)

        json_fr.close()
        json_fw.close()
        self.cc_log("INFO", "%i (btree) & %i (keyerror) records could not be mached" % (len(b_tree), failed_counter))
        self.cc_log("INFO", "Data Processing Join: Finished")
        return True

    def validate(self, kwargs):
        """
        Validates all arguments for the join module.

        **Parameters**:
            kwargs : dict
                contains a dictionary of all attributes.
        """
        super().validate(kwargs)
        self.cc_log("INFO", "Data Processing Join: started validation")
        if not kwargs.get("left-joinon"):
            raise ValidationError(self, ["left-joinon"], "Parameter cannot be empty!")
        if not kwargs.get("right-joinon"):
            raise ValidationError(self, ["right-joinon"], "Parameter cannot be empty!")
        if not kwargs.get("joinwith"):
            raise ValidationError(self, ["joinwith"], "Parameter cannot be empty!")
        self.cc_log("INFO", "Data Processing Join: finished validation")

    def join(self, b_tree, key, data, failed_counter):
        """
        Joins the given data with the data from the given B-Tree and removes it.
        If no entry can be found a log message is printed. The morphed data will be returned.

        **Parameters**:
            b-tree : B-Tree
                the B-Tree that has to be searched.
            key : str
                the key string for which has to be searched.
            data : dict
                the left table data.
            failed_counter : int
                counter to keep track of key error entries.

        **Returns**:
            The modified ``data`` and the modified ``b_tree`` in a tuple: ``(data, b_tree)``
        """
        try:
            # Try to find a match
            right_data = b_tree.pop(key)
            data['right_data'] = right_data
        except KeyError:
            # If no match if found catch the exception and carry on
            self.cc_log("INFO", "Could not find any data for the key %s" % key)
            failed_counter += 1

        return (data, b_tree, failed_counter)

    def depends_on_file(self):
        """
        Overwrite base method 'depends_on_file'.

        The join module depends on the 'joinwith' file. If it is not already existing from the beginning
        and it will be generated by another path in the script config we have to await this task.

        **Returns**:
            ``str`` with the depending attribute name where the depending file is defined.
        """
        return 'joinwith'  # Join depends on the 'joinwith' attribute
